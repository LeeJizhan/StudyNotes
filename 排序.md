# -概述
# -排序（sort）：将一个数据元素的任意序列，重新排列成一个按关键字有序的序列
# -数据表（datalist）：待排序数据对象的有限集合
# -关键字（key）：数据对象有多个属性域，即多个数据成员组成，其中一个属性域可以用来区分对象，作为排序依据，成为关键字

# -排序 c、、
# typedef int sortData;
# 插入排序---
1.直接插入排序
void InsertSort(sortData v[],int n)
{     //升序排序
  for(int i=2;i<=n;i++)
  {
    v[0]=v[i];//v[0]作为监视哨，第一个默认有序
    j=i-1;
    while(v[0]<v[j])//找位置，后移
    {
      v[j+1]=v[j];
      j--;
    }
    v[j+1]=v[0];//插入
  }
}

2.折半插入排序
void BinInsertSort(sortData v[],int n)
{    //升序排序
  int left,right;
  sortDara temp;
  for(int i=1;i<n;i++)
  {
    left=0;
    right=i-1;
    temp=v[i];//要插入的元素
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(temp<v[mid])//说明在mid的左边
        right=mid-1;
      else          //在mid的右边
        left=mid+1;
    }
    for(int k=i-1;k>=left;k--)//元素后移，left为插入位置
      v[k+1]=v[k];
    v[left]=temp;//插入
  }
}

3.希尔插入排序
void XierInsertSort(SqList v[],int dk,int n)//dk为增量
{
  for(int i=1+dk;i<n;++i)
  {
    if(v[i]<v[i-dk])
    {
      v[0]=v[i];
      for(j=i-dk;j>0&&v[0]<v[j];j-=dk)
      {
        v[j+dk]=v[j];
      }
      v[j+dk]=v[0];
    }
  }
}

void XierSort(SqList v[];int data[];int n)
{
  for(int i=0;i<n;i++)
    XierInsertSort(v,data[i],n);
}

4.快速排序
int Partition(SqList v[],int low,int high)
{
  v[0]=v[low];                 //子表的第一个记录作基准对象
  while(low<high)
  {
    while(low<high&&v[high]>=v[0]) 
      --high;
    v[low] =v[high];          //小于基准对象的移到区间的左侧
    while(low<high&&v[low]<=v[0]) 
      ++low;
    v[high]=v[low];            //大于基准对象的移到区间的右侧
  }    
  v[low]=v[0];
  return low;
}

void QuickSort(SqList v[],int low,int high)
{    //在序列lowhigh中递归地进行快速排序
  if(low<high)
  {					
    int p=Partition(v,low,high);    //划分
    QuickSort(v,low,p-1);   //对左序列同样处理
    QuickSort(v,p+1,high); //对右序列同样处理 
  }
}

5.上起泡排序算法
void Swap(sortData a,sortData b)
{
  a=a+b;
  b=a-b;
  a=a-b;
}

void BubbleSort(sortData v[],int n)
{
  int i=1; 
  int exchange=1;
  while(i<n&&exchange)
  {
    exchange=0;	//标志置为0,假定未交换
    for(int j=n-1;j>=i;j--)
      if(V[j-1]>V[j])
      { 	 //逆序   
			  Swap(v[j-1],v[j]); //交换
	      exchange=1; //标志置为1,有交换
      }
    i++;
  }
}                                          

# 选择排序---
1.直接选择排序
void SlectSort(sortData v[],int n)
{
  for(int i=0;i<n-1;i++)
  {
    int k=i;     //选择具有最小排序码的对象
    for(int j=i+1;j<n;j++)
      if(v[j]<v[k])
        k=j;    //当前具有最小排序码的对象
    if(k!=i)
      Swap(v[i],v[k]);   //交换
  }
}
